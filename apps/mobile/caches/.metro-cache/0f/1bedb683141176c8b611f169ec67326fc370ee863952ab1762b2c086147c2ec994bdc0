{"dependencies":[{"name":"../type/definition.mjs","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":1,"column":0,"index":0},"end":{"line":7,"column":32,"index":125}}],"key":"hpLFFXhPDbJgAZW4WoRQJKwpJT4=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  exports.isEqualType = isEqualType;\n  exports.isTypeSubTypeOf = isTypeSubTypeOf;\n  exports.doTypesOverlap = doTypesOverlap;\n  var _typeDefinitionMjs = require(_dependencyMap[0]);\n  /**\n   * Provided two types, return true if the types are equal (invariant).\n   */\n  function isEqualType(typeA, typeB) {\n    // Equivalent types are equal.\n    if (typeA === typeB) {\n      return true;\n    } // If either type is non-null, the other must also be non-null.\n\n    if ((0, _typeDefinitionMjs.isNonNullType)(typeA) && (0, _typeDefinitionMjs.isNonNullType)(typeB)) {\n      return isEqualType(typeA.ofType, typeB.ofType);\n    } // If either type is a list, the other must also be a list.\n\n    if ((0, _typeDefinitionMjs.isListType)(typeA) && (0, _typeDefinitionMjs.isListType)(typeB)) {\n      return isEqualType(typeA.ofType, typeB.ofType);\n    } // Otherwise the types are not equal.\n\n    return false;\n  }\n  /**\n   * Provided a type and a super type, return true if the first type is either\n   * equal or a subset of the second super type (covariant).\n   */\n\n  function isTypeSubTypeOf(schema, maybeSubType, superType) {\n    // Equivalent type is a valid subtype\n    if (maybeSubType === superType) {\n      return true;\n    } // If superType is non-null, maybeSubType must also be non-null.\n\n    if ((0, _typeDefinitionMjs.isNonNullType)(superType)) {\n      if ((0, _typeDefinitionMjs.isNonNullType)(maybeSubType)) {\n        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n      }\n      return false;\n    }\n    if ((0, _typeDefinitionMjs.isNonNullType)(maybeSubType)) {\n      // If superType is nullable, maybeSubType may be non-null or nullable.\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n    } // If superType type is a list, maybeSubType type must also be a list.\n\n    if ((0, _typeDefinitionMjs.isListType)(superType)) {\n      if ((0, _typeDefinitionMjs.isListType)(maybeSubType)) {\n        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n      }\n      return false;\n    }\n    if ((0, _typeDefinitionMjs.isListType)(maybeSubType)) {\n      // If superType is not a list, maybeSubType must also be not a list.\n      return false;\n    } // If superType type is an abstract type, check if it is super type of maybeSubType.\n    // Otherwise, the child type is not a valid subtype of the parent type.\n\n    return (0, _typeDefinitionMjs.isAbstractType)(superType) && ((0, _typeDefinitionMjs.isInterfaceType)(maybeSubType) || (0, _typeDefinitionMjs.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);\n  }\n  /**\n   * Provided two composite types, determine if they \"overlap\". Two composite\n   * types overlap when the Sets of possible concrete types for each intersect.\n   *\n   * This is often used to determine if a fragment of a given type could possibly\n   * be visited in a context of another type.\n   *\n   * This function is commutative.\n   */\n\n  function doTypesOverlap(schema, typeA, typeB) {\n    // Equivalent types overlap\n    if (typeA === typeB) {\n      return true;\n    }\n    if ((0, _typeDefinitionMjs.isAbstractType)(typeA)) {\n      if ((0, _typeDefinitionMjs.isAbstractType)(typeB)) {\n        // If both types are abstract, then determine if there is any intersection\n        // between possible concrete types of each.\n        return schema.getPossibleTypes(typeA).some(type => schema.isSubType(typeB, type));\n      } // Determine if the latter type is a possible concrete type of the former.\n\n      return schema.isSubType(typeA, typeB);\n    }\n    if ((0, _typeDefinitionMjs.isAbstractType)(typeB)) {\n      // Determine if the former type is a possible concrete type of the latter.\n      return schema.isSubType(typeB, typeA);\n    } // Otherwise the types do not overlap.\n\n    return false;\n  }\n});","lineCount":97,"map":[[7,2,12,0,"exports"],[7,9,12,0],[7,10,12,0,"isEqualType"],[7,21,12,0],[7,24,12,0,"isEqualType"],[7,35,12,0],[8,2,33,0,"exports"],[8,9,33,0],[8,10,33,0,"isTypeSubTypeOf"],[8,25,33,0],[8,28,33,0,"isTypeSubTypeOf"],[8,43,33,0],[9,2,82,0,"exports"],[9,9,82,0],[9,10,82,0,"doTypesOverlap"],[9,24,82,0],[9,27,82,0,"doTypesOverlap"],[9,41,82,0],[10,2,1,0],[10,6,1,0,"_typeDefinitionMjs"],[10,24,1,0],[10,27,1,0,"require"],[10,34,1,0],[10,35,1,0,"_dependencyMap"],[10,49,1,0],[11,2,9,0],[12,0,10,0],[13,0,11,0],[14,2,12,7],[14,11,12,16,"isEqualType"],[14,22,12,27,"isEqualType"],[14,23,12,28,"typeA"],[14,28,12,33],[14,30,12,35,"typeB"],[14,35,12,40],[14,37,12,42],[15,4,13,2],[16,4,14,2],[16,8,14,6,"typeA"],[16,13,14,11],[16,18,14,16,"typeB"],[16,23,14,21],[16,25,14,23],[17,6,15,4],[17,13,15,11],[17,17,15,15],[18,4,16,2],[18,5,16,3],[18,6,16,4],[20,4,18,2],[20,8,18,6],[20,12,18,6,"isNonNullType"],[20,30,18,19],[20,31,18,19,"isNonNullType"],[20,44,18,19],[20,46,18,20,"typeA"],[20,51,18,25],[20,52,18,26],[20,56,18,30],[20,60,18,30,"isNonNullType"],[20,78,18,43],[20,79,18,43,"isNonNullType"],[20,92,18,43],[20,94,18,44,"typeB"],[20,99,18,49],[20,100,18,50],[20,102,18,52],[21,6,19,4],[21,13,19,11,"isEqualType"],[21,24,19,22],[21,25,19,23,"typeA"],[21,30,19,28],[21,31,19,29,"ofType"],[21,37,19,35],[21,39,19,37,"typeB"],[21,44,19,42],[21,45,19,43,"ofType"],[21,51,19,49],[21,52,19,50],[22,4,20,2],[22,5,20,3],[22,6,20,4],[24,4,22,2],[24,8,22,6],[24,12,22,6,"isListType"],[24,30,22,16],[24,31,22,16,"isListType"],[24,41,22,16],[24,43,22,17,"typeA"],[24,48,22,22],[24,49,22,23],[24,53,22,27],[24,57,22,27,"isListType"],[24,75,22,37],[24,76,22,37,"isListType"],[24,86,22,37],[24,88,22,38,"typeB"],[24,93,22,43],[24,94,22,44],[24,96,22,46],[25,6,23,4],[25,13,23,11,"isEqualType"],[25,24,23,22],[25,25,23,23,"typeA"],[25,30,23,28],[25,31,23,29,"ofType"],[25,37,23,35],[25,39,23,37,"typeB"],[25,44,23,42],[25,45,23,43,"ofType"],[25,51,23,49],[25,52,23,50],[26,4,24,2],[26,5,24,3],[26,6,24,4],[28,4,26,2],[28,11,26,9],[28,16,26,14],[29,2,27,0],[30,2,28,0],[31,0,29,0],[32,0,30,0],[33,0,31,0],[35,2,33,7],[35,11,33,16,"isTypeSubTypeOf"],[35,26,33,31,"isTypeSubTypeOf"],[35,27,33,32,"schema"],[35,33,33,38],[35,35,33,40,"maybeSubType"],[35,47,33,52],[35,49,33,54,"superType"],[35,58,33,63],[35,60,33,65],[36,4,34,2],[37,4,35,2],[37,8,35,6,"maybeSubType"],[37,20,35,18],[37,25,35,23,"superType"],[37,34,35,32],[37,36,35,34],[38,6,36,4],[38,13,36,11],[38,17,36,15],[39,4,37,2],[39,5,37,3],[39,6,37,4],[41,4,39,2],[41,8,39,6],[41,12,39,6,"isNonNullType"],[41,30,39,19],[41,31,39,19,"isNonNullType"],[41,44,39,19],[41,46,39,20,"superType"],[41,55,39,29],[41,56,39,30],[41,58,39,32],[42,6,40,4],[42,10,40,8],[42,14,40,8,"isNonNullType"],[42,32,40,21],[42,33,40,21,"isNonNullType"],[42,46,40,21],[42,48,40,22,"maybeSubType"],[42,60,40,34],[42,61,40,35],[42,63,40,37],[43,8,41,6],[43,15,41,13,"isTypeSubTypeOf"],[43,30,41,28],[43,31,41,29,"schema"],[43,37,41,35],[43,39,41,37,"maybeSubType"],[43,51,41,49],[43,52,41,50,"ofType"],[43,58,41,56],[43,60,41,58,"superType"],[43,69,41,67],[43,70,41,68,"ofType"],[43,76,41,74],[43,77,41,75],[44,6,42,4],[45,6,44,4],[45,13,44,11],[45,18,44,16],[46,4,45,2],[47,4,47,2],[47,8,47,6],[47,12,47,6,"isNonNullType"],[47,30,47,19],[47,31,47,19,"isNonNullType"],[47,44,47,19],[47,46,47,20,"maybeSubType"],[47,58,47,32],[47,59,47,33],[47,61,47,35],[48,6,48,4],[49,6,49,4],[49,13,49,11,"isTypeSubTypeOf"],[49,28,49,26],[49,29,49,27,"schema"],[49,35,49,33],[49,37,49,35,"maybeSubType"],[49,49,49,47],[49,50,49,48,"ofType"],[49,56,49,54],[49,58,49,56,"superType"],[49,67,49,65],[49,68,49,66],[50,4,50,2],[50,5,50,3],[50,6,50,4],[52,4,52,2],[52,8,52,6],[52,12,52,6,"isListType"],[52,30,52,16],[52,31,52,16,"isListType"],[52,41,52,16],[52,43,52,17,"superType"],[52,52,52,26],[52,53,52,27],[52,55,52,29],[53,6,53,4],[53,10,53,8],[53,14,53,8,"isListType"],[53,32,53,18],[53,33,53,18,"isListType"],[53,43,53,18],[53,45,53,19,"maybeSubType"],[53,57,53,31],[53,58,53,32],[53,60,53,34],[54,8,54,6],[54,15,54,13,"isTypeSubTypeOf"],[54,30,54,28],[54,31,54,29,"schema"],[54,37,54,35],[54,39,54,37,"maybeSubType"],[54,51,54,49],[54,52,54,50,"ofType"],[54,58,54,56],[54,60,54,58,"superType"],[54,69,54,67],[54,70,54,68,"ofType"],[54,76,54,74],[54,77,54,75],[55,6,55,4],[56,6,57,4],[56,13,57,11],[56,18,57,16],[57,4,58,2],[58,4,60,2],[58,8,60,6],[58,12,60,6,"isListType"],[58,30,60,16],[58,31,60,16,"isListType"],[58,41,60,16],[58,43,60,17,"maybeSubType"],[58,55,60,29],[58,56,60,30],[58,58,60,32],[59,6,61,4],[60,6,62,4],[60,13,62,11],[60,18,62,16],[61,4,63,2],[61,5,63,3],[61,6,63,4],[62,4,64,2],[64,4,66,2],[64,11,67,4],[64,15,67,4,"isAbstractType"],[64,33,67,18],[64,34,67,18,"isAbstractType"],[64,48,67,18],[64,50,67,19,"superType"],[64,59,67,28],[64,60,67,29],[64,65,68,5],[64,69,68,5,"isInterfaceType"],[64,87,68,20],[64,88,68,20,"isInterfaceType"],[64,103,68,20],[64,105,68,21,"maybeSubType"],[64,117,68,33],[64,118,68,34],[64,122,68,38],[64,126,68,38,"isObjectType"],[64,144,68,50],[64,145,68,50,"isObjectType"],[64,157,68,50],[64,159,68,51,"maybeSubType"],[64,171,68,63],[64,172,68,64],[64,173,68,65],[64,177,69,4,"schema"],[64,183,69,10],[64,184,69,11,"isSubType"],[64,193,69,20],[64,194,69,21,"superType"],[64,203,69,30],[64,205,69,32,"maybeSubType"],[64,217,69,44],[64,218,69,45],[65,2,71,0],[66,2,72,0],[67,0,73,0],[68,0,74,0],[69,0,75,0],[70,0,76,0],[71,0,77,0],[72,0,78,0],[73,0,79,0],[74,0,80,0],[76,2,82,7],[76,11,82,16,"doTypesOverlap"],[76,25,82,30,"doTypesOverlap"],[76,26,82,31,"schema"],[76,32,82,37],[76,34,82,39,"typeA"],[76,39,82,44],[76,41,82,46,"typeB"],[76,46,82,51],[76,48,82,53],[77,4,83,2],[78,4,84,2],[78,8,84,6,"typeA"],[78,13,84,11],[78,18,84,16,"typeB"],[78,23,84,21],[78,25,84,23],[79,6,85,4],[79,13,85,11],[79,17,85,15],[80,4,86,2],[81,4,88,2],[81,8,88,6],[81,12,88,6,"isAbstractType"],[81,30,88,20],[81,31,88,20,"isAbstractType"],[81,45,88,20],[81,47,88,21,"typeA"],[81,52,88,26],[81,53,88,27],[81,55,88,29],[82,6,89,4],[82,10,89,8],[82,14,89,8,"isAbstractType"],[82,32,89,22],[82,33,89,22,"isAbstractType"],[82,47,89,22],[82,49,89,23,"typeB"],[82,54,89,28],[82,55,89,29],[82,57,89,31],[83,8,90,6],[84,8,91,6],[85,8,92,6],[85,15,92,13,"schema"],[85,21,92,19],[85,22,93,9,"getPossibleTypes"],[85,38,93,25],[85,39,93,26,"typeA"],[85,44,93,31],[85,45,93,32],[85,46,94,9,"some"],[85,50,94,13],[85,51,94,15,"type"],[85,55,94,19],[85,59,94,24,"schema"],[85,65,94,30],[85,66,94,31,"isSubType"],[85,75,94,40],[85,76,94,41,"typeB"],[85,81,94,46],[85,83,94,48,"type"],[85,87,94,52],[85,88,94,53],[85,89,94,54],[86,6,95,4],[86,7,95,5],[86,8,95,6],[88,6,97,4],[88,13,97,11,"schema"],[88,19,97,17],[88,20,97,18,"isSubType"],[88,29,97,27],[88,30,97,28,"typeA"],[88,35,97,33],[88,37,97,35,"typeB"],[88,42,97,40],[88,43,97,41],[89,4,98,2],[90,4,100,2],[90,8,100,6],[90,12,100,6,"isAbstractType"],[90,30,100,20],[90,31,100,20,"isAbstractType"],[90,45,100,20],[90,47,100,21,"typeB"],[90,52,100,26],[90,53,100,27],[90,55,100,29],[91,6,101,4],[92,6,102,4],[92,13,102,11,"schema"],[92,19,102,17],[92,20,102,18,"isSubType"],[92,29,102,27],[92,30,102,28,"typeB"],[92,35,102,33],[92,37,102,35,"typeA"],[92,42,102,40],[92,43,102,41],[93,4,103,2],[93,5,103,3],[93,6,103,4],[95,4,105,2],[95,11,105,9],[95,16,105,14],[96,2,106,0],[97,0,106,1],[97,3]],"functionMap":{"names":["<global>","isEqualType","isTypeSubTypeOf","doTypesOverlap","schema.getPossibleTypes.some$argument_0"],"mappings":"AAA;OCW;CDe;OEM;CFsC;OGW;cCY,uCD;CHY"},"hasCjsExports":false},"type":"js/module"}]}